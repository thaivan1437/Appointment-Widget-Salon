{"ast":null,"code":"\"use strict\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nexports.__esModule = true;\nexports.pathToRegexp = exports.default = exports.customRouteMatcherOptions = exports.matcherOptions = void 0;\n\nvar pathToRegexp = _interopRequireWildcard(require(\"next/dist/compiled/path-to-regexp\"));\n\nexports.pathToRegexp = pathToRegexp;\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar matcherOptions = {\n  sensitive: false,\n  delimiter: '/',\n  decode: decodeParam\n};\nexports.matcherOptions = matcherOptions;\n\nvar customRouteMatcherOptions = _objectSpread({}, matcherOptions, {\n  strict: true\n});\n\nexports.customRouteMatcherOptions = customRouteMatcherOptions;\n\nvar _default = function _default() {\n  var customRoute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return function (path) {\n    var keys = [];\n    var matcherRegex = pathToRegexp.pathToRegexp(path, keys, customRoute ? customRouteMatcherOptions : matcherOptions);\n    var matcher = pathToRegexp.regexpToFunction(matcherRegex, keys, matcherOptions);\n    return function (pathname, params) {\n      var res = pathname == null ? false : matcher(pathname);\n\n      if (!res) {\n        return false;\n      }\n\n      if (customRoute) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var key = _step.value;\n\n            // unnamed params should be removed as they\n            // are not allowed to be used in the destination\n            if (typeof key.name === 'number') {\n              delete res.params[key.name];\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      return _objectSpread({}, params, {}, res.params);\n    };\n  };\n};\n\nexports.default = _default;\n\nfunction decodeParam(param) {\n  try {\n    return decodeURIComponent(param);\n  } catch (_) {\n    var _err = new Error('failed to decode param');\n\n    _err.code = 'DECODE_FAILED';\n    throw _err;\n  }\n}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/path-match.ts"],"names":["matcherOptions","sensitive","delimiter","decode","customRouteMatcherOptions","strict","customRoute","path","keys","matcherRegex","pathToRegexp","matcher","res","pathname","key","decodeURIComponent","err"],"mappings":";;;;;;;;;;;;;AAAA,IAAA,YAAA,GAAA,uBAAA,CAAA,OAAA,CAAA,mCAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIO;;AAAA,IAAMA,cAAc,GAAG;AAC5BC,EAAAA,SAAS,EADmB,KAAA;AAE5BC,EAAAA,SAAS,EAFmB,GAAA;AAG5BC,EAAAA,MAAM,EAHD;AAAuB,CAAvB;;;AAMA,IAAMC,yBAAyB,qBAAG,cAAH;AAEpCC,EAAAA,MAAM,EAFD;AAA+B,EAA/B;;;;eAKQ,S,QAAA,GAAyB;AAAA,MAAxBC,WAAwB,uEAAzB,KAAyB;AACtC,SAAQC,UAAAA,IAAD,EAAkB;AACvB,QAAMC,IAAwB,GAA9B,EAAA;AACA,QAAMC,YAAY,GAAGC,YAAY,CAAZA,YAAAA,CAAAA,IAAAA,EAAAA,IAAAA,EAGnBJ,WAAW,GAAA,yBAAA,GAHb,cAAqBI,CAArB;AAKA,QAAMC,OAAO,GAAGD,YAAY,CAAZA,gBAAAA,CAAAA,YAAAA,EAAAA,IAAAA,EAAhB,cAAgBA,CAAhB;AAMA,WAAO,UAAA,QAAA,EAAA,MAAA,EAAuD;AAC5D,UAAME,GAAG,GAAGC,QAAQ,IAARA,IAAAA,GAAAA,KAAAA,GAA2BF,OAAO,CAA9C,QAA8C,CAA9C;;AACA,UAAI,CAAJ,GAAA,EAAU;AACR,eAAA,KAAA;AAGF;;AAAA,UAAA,WAAA,EAAiB;AAAA;AAAA;AAAA;;AAAA;AACf,+BAAA,IAAA,8HAAwB;AAAA,gBAAxB,GAAwB;;AACtB;AACA;AACA,gBAAI,OAAOG,GAAG,CAAV,IAAA,KAAJ,QAAA,EAAkC;AAChC,qBAAQF,GAAG,CAAJ,MAACA,CAAmBE,GAAG,CAA9B,IAAQF,CAAR;AAEH;AACF;AARgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUjB;;AAAA,+BAAO,MAAP,MAAuBA,GAAG,CAA1B,MAAA;AAhBF,KAAA;AAbF,GAAA;;;;;AAkCF,SAAA,WAAA,CAAA,KAAA,EAAoC;AAClC,MAAI;AACF,WAAOG,kBAAkB,CAAzB,KAAyB,CAAzB;AACA,GAFF,CAEE,OAAA,CAAA,EAAU;AACV,QAAMC,IAA8B,GAAG,IAAA,KAAA,CAAvC,wBAAuC,CAAvC;;AACAA,IAAAA,IAAG,CAAHA,IAAAA,GAAAA,eAAAA;AACA,UAAA,IAAA;AAEH;AAAA","sourcesContent":["import * as pathToRegexp from 'next/dist/compiled/path-to-regexp'\n\nexport { pathToRegexp }\n\nexport const matcherOptions = {\n  sensitive: false,\n  delimiter: '/',\n  decode: decodeParam,\n}\n\nexport const customRouteMatcherOptions = {\n  ...matcherOptions,\n  strict: true,\n}\n\nexport default (customRoute = false) => {\n  return (path: string) => {\n    const keys: pathToRegexp.Key[] = []\n    const matcherRegex = pathToRegexp.pathToRegexp(\n      path,\n      keys,\n      customRoute ? customRouteMatcherOptions : matcherOptions\n    )\n    const matcher = pathToRegexp.regexpToFunction(\n      matcherRegex,\n      keys,\n      matcherOptions\n    )\n\n    return (pathname: string | null | undefined, params?: any) => {\n      const res = pathname == null ? false : matcher(pathname)\n      if (!res) {\n        return false\n      }\n\n      if (customRoute) {\n        for (const key of keys) {\n          // unnamed params should be removed as they\n          // are not allowed to be used in the destination\n          if (typeof key.name === 'number') {\n            delete (res.params as any)[key.name]\n          }\n        }\n      }\n\n      return { ...params, ...res.params }\n    }\n  }\n}\n\nfunction decodeParam(param: string) {\n  try {\n    return decodeURIComponent(param)\n  } catch (_) {\n    const err: Error & { code?: string } = new Error('failed to decode param')\n    err.code = 'DECODE_FAILED'\n    throw err\n  }\n}\n"]},"metadata":{},"sourceType":"script"}